// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2024-Present Harry Randazzo

// Package main is the entrypoint for generating words/gen.go from /usr/share/dict/words
package main

import (
	"bufio"
	"io"
	"net/http"
	"os"
	"strings"
	"text/template"
)

func main() {
	f, err := os.Open("/usr/share/dict/words")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	var words []string

	scanner := bufio.NewScanner(f)

	for scanner.Scan() {
		line := scanner.Text()

		stripped := strings.Trim(line, " ")
		if strings.Contains(stripped, "'") || len(stripped) < 3 {
			continue
		}

		words = append(words, stripped)
	}

	tmpl := template.New("words")

	tmpl, err = tmpl.Parse(`// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2024-Present Harry Randazzo

package words

// generated by make generate DO NOT EDIT

var USR_SHARE_DICT = [{{ len . }}]string{ {{range $word := .}}
	"{{$word}}",{{end}}
}
`)
	if err != nil {
		panic(err)
	}

	w, err := os.Create("gen_usr_share_dict.go")
	if err != nil {
		panic(err)
	}
	defer w.Close()

	if err := tmpl.Execute(w, words); err != nil {
		panic(err)
	}

	client := &http.Client{}

	req, err := http.NewRequest(http.MethodGet, "https://www.eff.org/files/2016/07/18/eff_large_wordlist.txt", nil)
	if err != nil {
		panic(err)
	}

	res, err := client.Do(req)
	if err != nil {
		panic(err)
	}

	defer res.Body.Close()

	b, err := io.ReadAll(res.Body)
	if err != nil {
		panic(err)
	}

	tmpl = template.New("eff").Funcs(template.FuncMap{
		"lines": func(s string) []string {
			return strings.Split(strings.TrimSpace(s), "\n")
		},
		"fields": strings.Fields,
	})

	tmpl, err = tmpl.Parse(`// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2024-Present Harry Randazzo

package words

// generated by make generate DO NOT EDIT

var EFF = map[int]string{ {{range $line := lines .}}{{$fields := fields $line}}{{if eq (len $fields) 2}}
	{{index $fields 0}}: "{{index $fields 1}}",{{end}}{{end}}
}
`)
	if err != nil {
		panic(err)
	}

	eff, err := os.Create("gen_eff.go")
	if err != nil {
		panic(err)
	}
	defer eff.Close()

	if err := tmpl.Execute(eff, string(b)); err != nil {
		panic(err)
	}
}
